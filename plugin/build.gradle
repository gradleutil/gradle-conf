plugins {
    id 'groovy-gradle-plugin'
    id 'maven-publish'
    id "com.gradle.plugin-publish" version "0.12.0"
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

version = project.version != 'unspecified' ? project.version : file('VERSION').text.trim()
group = 'net.gradleutil'

sourceSets {
    testPlugin {
    }
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://jitpack.io" }
}

def confVer = '1.1.0'

configurations {
    embedded
}

dependencies {
//    implementation project(path: ":gradle-conf-gen")

    //shadow localGroovy()
    //shadow gradleApi()
    embedded ("net.gradleutil:conf-gen:${confVer}"){
        transitive = false
    }
    embedded ("net.gradleutil:gradle-conf-gen:${confVer}"){
        transitive = false
    }
    //shadow gradleApi()
    //shadow 'org.codehaus.groovy:groovy-all:3.0.10'

    testFixtures ("net.gradleutil:conf-gen:${confVer}")
    testImplementation ("net.gradleutil:conf-gen:${confVer}:test-fixtures")
}

configurations.implementation.extendsFrom(configurations.embedded)
gradlePlugin.testSourceSets(sourceSets.testPlugin)
configurations.testImplementation.extendsFrom(configurations.embedded)
configurations.testPluginImplementation.extendsFrom(configurations.testImplementation)



testing{
    suites{
        test{
            useSpock( '2.1-groovy-3.0' )
        }
        testImplementation( JvmTestSuite ){
            useSpock( '2.1-groovy-3.0' )
            dependencies{
//                implementation project
            }

            targets{
                all{
                    testTask.configure{ shouldRunAfter( test ) }
                }
            }
        }
    }
}


java {
    withJavadocJar()
    withSourcesJar()
}

javadoc {
    exclude 'gg/jte/generated/**'
    failOnError = false
}

gradlePlugin {
    plugins {
        gradleconf {
            id = 'net.gradleutil.gradle-conf'
            implementationClass = 'net.gradleutil.config.ConfPlugin'
        }
    }
}


pluginBundle {
    website = 'https://github.com/gradleutil/gradle-conf'
    vcsUrl = 'https://github.com/gradleutil/gradle-conf'
    description = 'Configure your Gradle builds with HOCON'
    tags = ['build-tool', 'configuration', 'json', 'json-schema', 'lightbend-conf', 'typesafe-conf']

    plugins {
        gradleconf {
            id = 'net.gradleutil.gradle-conf'
            displayName = 'Configure projects with HOCON'
        }
    }
}

task testPlugin(type: Test, group: 'tests') {
    testClassesDirs = sourceSets.testPlugin.output.classesDirs
    classpath = sourceSets.testPlugin.runtimeClasspath
}

tasks.withType(Test) {
    // Show test results.
    group = 'tests'
    testLogging { it.events "passed", "skipped", "failed" }
//    testLogging.showStandardStreams = true
    testLogging.showCauses = true
    testLogging.exceptionFormat('full')
}

check {
    group = 'tests'
    dependsOn(tasks.testPlugin)
}

task artifactList {
    group = "Help"
    description = "Displays the artifacts associated with each configuration of " + project
    doFirst {
        configurations.findAll().each { config ->
            println "${config}:"
            config.allArtifacts.getFiles().each { file -> println " " + file }
            config.dependencies.each { dep -> println " dep:" + dep.toString() }
            println ' '
        }
    }
}


jar {
    enabled(false)
    archiveClassifier.set('core')
    dependsOn(shadowJar)
}

shadowJar {
    configurations = [project.configurations.embedded]
    mergeServiceFiles()
    mergeGroovyExtensionModules()
    minimize()
    archiveClassifier.set('')
    doLast {
        def jarFile = outputs.files.first() as File
        def formatStr = "%,10.2f"
        logger.lifecycle("Shadow jar:" + jarFile + "${String.format(formatStr, jarFile.length() / 1024)} Mb")
    }
}

artifacts {
    archives sourcesJar
    archives javadocJar
    archives shadowJar
}


// Replace any references to the core jar with the shadowed jar
PublishArtifact shadowedArtifact = configurations*.artifacts*.find { it.file.name.endsWith("${version}.jar") }.find()
configurations*.artifacts*.with { artifactSet ->
    PublishArtifact removeJarArtifact
    artifactSet.each {
        if (it.file.name.endsWith('core.jar')) {
            removeJarArtifact = it
        }
    }
    if (removeJarArtifact) {
        remove(removeJarArtifact)
        if (!artifactSet.contains(shadowedArtifact)) {
            add(shadowedArtifact)
        }
    }
}

tasks.withType(GenerateModuleMetadata) {
    enabled = false
}

project.afterEvaluate {
    /* remove shadowed dependencies that show up under the plugin otherwise */
    def removePomDep = { MavenPublication pub, NodeList depsNodeList ->
        depsNodeList['dependency'].each { dep ->
            if (dep.artifactId.last().value().last() in ["conf", "conf-gen", "gradle-conf-gen"]) {
                def artifactId = (dep.artifactId.first() as Node).value()
                def groupId = (dep.groupId.first() as Node).value()
                logger.info "Removed ${groupId}.${artifactId} from ${pub.name} POM dependency"
                assert dep.parent().remove(dep)
            }
        }
    }

    publishing.publications*.with(false) { pub ->
        if (pub instanceof MavenPublication) {
            pub.pom.withXml {
                removePomDep(pub, (asNode().get('dependencies') as NodeList))
            }
        }
    }
}


tasks.withType(AbstractPublishToMaven) { publishTask ->
    def printInfo = { AbstractPublishToMaven task, String repoPath ->
        task.publication.with { p ->
            def sb = new StringBuilder()
            p.artifacts.each {
                String artifactPath = p.groupId.replace(".", "/") + "/" + p.artifactId + "/" + p.version + "/"
                sb.append('\n  ' + repoPath).append(artifactPath)
                        .append(p.artifactId).append('-' + p.version)
                        .append(it.classifier ? '-' + it.classifier : '').append('.' + it.extension)
            }
            logger.lifecycle("Published ${p.groupId}:${p.artifactId}:${p.version}${sb.toString()}")
        }
    }
    doLast {
        if (publishTask instanceof PublishToMavenRepository) {
            printInfo(publishTask, publishTask.repository.url.toString())
        } else {
            String repoPath = repositories.mavenLocal().url.toURL().getFile()
            printInfo(publishTask, repoPath)
        }
    }
}