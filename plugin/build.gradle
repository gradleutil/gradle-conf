plugins {
    id 'groovy-gradle-plugin'
    id 'maven-publish'
    id "com.gradle.plugin-publish" version "0.12.0"
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id 'codenarc'
}

version = project.version != 'unspecified' ? project.version : file('VERSION').text.trim()
group = 'net.gradleutil'
sourceCompatibility = 1.8
targetCompatibility = 1.8

sourceSets {
    testPlugin {}
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "https://jitpack.io" }
}

def confGenVer = '1.1.15'
System.properties.setProperty('confGenVer',confGenVer)

codenarc {
    configFile = file("${rootProject.projectDir}/config/codenarc/rules.groovy")
    reportFormat = 'html'
    ignoreFailures = true
}

configurations {
    embedded
}

dependencies {
    //    implementation project(path: ":gradle-conf-gen")

    embedded("net.gradleutil:conf-gen:${confGenVer}") {
        transitive = false
    }
    embedded("net.gradleutil:gradle-conf-gen:+") {
        transitive = false
    }

    //shadow gradleApi()
    //shadow 'org.codehaus.groovy:groovy-all:3.0.10'

    testFixtures("net.gradleutil:conf-gen:${confGenVer}")
    testImplementation("net.gradleutil:conf-gen:${confGenVer}:test-fixtures")
}

configurations.implementation.extendsFrom(configurations.embedded)
gradlePlugin.testSourceSets(sourceSets.testPlugin)
configurations.testImplementation.extendsFrom(configurations.embedded)
configurations.testPluginImplementation.extendsFrom(configurations.testImplementation)

testing {
    suites {
        test {
            useSpock('2.1-groovy-3.0')
        }
        testImplementation(JvmTestSuite) {
            useSpock('2.1-groovy-3.0')
            dependencies {
                //                implementation project
            }

            targets {
                all {
                    testTask.configure { shouldRunAfter(test) }
                }
            }
        }
    }
}


java {
    withJavadocJar()
    withSourcesJar()
}

javadoc {
    exclude 'gg/jte/generated/**'
    failOnError = false
}

gradlePlugin {
    plugins {
        gradleconf {
            id = 'net.gradleutil.gradle-conf'
            implementationClass = 'net.gradleutil.config.ConfPlugin'
        }
    }
}


pluginBundle {
    website = 'https://github.com/gradleutil/gradle-conf'
    vcsUrl = 'https://github.com/gradleutil/gradle-conf'
    description = 'Configure your Gradle builds with HOCON'
    tags = ['build-tool', 'configuration', 'json', 'json-schema', 'lightbend-conf', 'typesafe-conf']

    plugins {
        gradleconf {
            id = 'net.gradleutil.gradle-conf'
            displayName = 'Configure projects with HOCON'
        }
    }
}

task testPlugin(type: Test, group: 'tests') {
    testClassesDirs = sourceSets.testPlugin.output.classesDirs
    classpath = sourceSets.testPlugin.runtimeClasspath
    systemProperty 'confGenVer', confGenVer
    useJUnitPlatform()
}

tasks.withType(Test) {
    // Show test results.
    group = 'tests'
    testLogging { it.events "passed", "skipped", "failed" }
    //    testLogging.showStandardStreams = true
    testLogging.showCauses = true
    testLogging.exceptionFormat('full')
}

check {
    group = 'tests'
    dependsOn(tasks.testPlugin)
}

task artifactList {
    group = "Help"
    description = "Displays the artifacts associated with each configuration of " + project
    doFirst {
        configurations.each { config ->
            println "${config}:"
            config.allArtifacts.getFiles().each { file -> println " " + file }
            config.dependencies.each { dep -> println " dep:" + dep.toString() }
            println ' '
        }
    }
}


jar {
    enabled(false)
    archiveClassifier.set('core')
    dependsOn(shadowJar)
}

shadowJar {
    configurations = [project.configurations.embedded]
    mergeServiceFiles()
    mergeGroovyExtensionModules()
    archiveClassifier.set('')
    doLast {
        def jarFile = outputs.files.first() as File
        def formatStr = "%,10.2f"
        logger.lifecycle("Shadow jar:" + jarFile + "${String.format(formatStr, jarFile.length() / 1024)} Mb")
    }
}

artifacts {
    archives sourcesJar
    archives javadocJar
    archives shadowJar
}


// Replace any references to the core jar with the shadowed jar
PublishArtifact shadowedArtifact = configurations*.artifacts*.find { it.file.name.endsWith("${version}.jar") }.find()
configurations*.artifacts*.with { artifactSet ->
    PublishArtifact removeJarArtifact
    artifactSet.each {
        if (it.file.name.endsWith('core.jar')) {
            removeJarArtifact = it
        }
    }
    if (removeJarArtifact) {
        remove(removeJarArtifact)
        if (!artifactSet.contains(shadowedArtifact)) {
            add(shadowedArtifact)
        }
    }
}

tasks.withType(GenerateModuleMetadata) {
    enabled = false
}

project.afterEvaluate {
    /* remove shadowed dependencies that show up under the plugin otherwise */
    def removePomDep = { MavenPublication pub, NodeList depsNodeList ->
        depsNodeList['dependency'].each { dep ->
            if (dep.artifactId.last().value().last() in ["conf", "conf-gen", "gradle-conf-gen"]) {
                def artifactId = (dep.artifactId.first() as Node).value()
                def groupId = (dep.groupId.first() as Node).value()
                logger.info "Removed ${groupId}.${artifactId} from ${pub.name} POM dependency"
                assert dep.parent().remove(dep)
            }
        }
    }

    publishing.publications*.with(false) { pub ->
        if (pub instanceof MavenPublication) {
            pub.pom.withXml {
                removePomDep(pub, (asNode().get('dependencies') as NodeList))
            }
        }
    }
}


tasks.register("depsize") {
    description = 'Prints dependencies for "default" configuration'
    doLast() {
        listConfigurationDependencies(configurations.default)
    }
}

tasks.register("depsize-all") {
    description = 'Prints dependencies for all available configurations'
    doLast() {
        configurations
                .findAll { it.isCanBeResolved() }
                .each { listConfigurationDependencies(it) }
    }
}

def listConfigurationDependencies(Configuration configuration) {
    def formatStr = "%,10.2f"

    def size = configuration.collect { it.length() / (1024 * 1024) }.sum()

    def out = new StringBuffer()
    out << "\nConfiguration name: \"${configuration.name}\"\n"
    if (size) {
        out << 'Total dependencies size:'.padRight(65)
        out << "${String.format(formatStr, size)} Mb\n\n"

        configuration.sort { -it.length() }
                .each {
                    out << "${it.name}".padRight(65)
                    out << "${String.format(formatStr, (it.length() / 1024))} kb\n"
                }
    } else {
        out << 'No dependencies found'
    }
    println(out)
}


tasks.withType(AbstractPublishToMaven) { publishTask ->
    def printInfo = { AbstractPublishToMaven task, String repoPath ->
        task.publication.with { p ->
            def sb = new StringBuilder()
            p.artifacts.each {
                String artifactPath = p.groupId.replace(".", "/") + "/" + p.artifactId + "/" + p.version + "/"
                sb.append('\n  ' + repoPath).append(artifactPath)
                        .append(p.artifactId).append('-' + p.version)
                        .append(it.classifier ? '-' + it.classifier : '').append('.' + it.extension)
            }
            logger.lifecycle("Published ${p.groupId}:${p.artifactId}:${p.version}${sb.toString()}")
        }
    }
    doLast {
        if (publishTask instanceof PublishToMavenRepository) {
            printInfo(publishTask, publishTask.repository.url.toString())
        } else {
            String repoPath = repositories.mavenLocal().url.toURL().getFile()
            printInfo(publishTask, repoPath)
        }
    }
}
